Events – Stores the detailed event log for each journey. Key fields: event_id (PK), journey_id (FK to Journeys), activity_name (the event/task name), timestamp, and any other relevant attributes (user, resource, etc.). An index on journey_id supports fast retrieval of all events for a given case. This table can be partitioned (for example, by event date or by journey_id hash) to distribute large logs. Partitioning improves manageability and performance by keeping active data in smaller chunks and allowing partition elimination for queries on time ranges​
DEV.TO
. Variants – Defines each unique sequence of activities. Fields might include variant_id (PK) and a representation of the sequence (e.g. an ordered list of activity_name or a hashed sequence signature). Storing the sequence as a JSON array or a delimited string is efficient for reference. This table is relatively small (one row per variant) and can be indexed by any sequence attributes if needed. Every journey links to one variant; thus, variant statistics (like frequency counts) can be derived by joining or counting journeys per variant. Process Models – Stores discovered process models (e.g. BPMN diagrams, Petri nets) for the process. Fields: model_id (PK), model_name/version, model type (notation), and model_data. The model_data can be stored as a compressed JSON or XML (for BPMN) or as a binary blob if using a proprietary format. For example, BPMN XML files or Petri net definitions can be stored in a BLOB column (similar to how Camunda stores BPMN diagrams in a bytearray table) for efficient retrieval​
FORUM.CAMUNDA.IO
. This table is small but might store large payloads per row, so use compression or binary storage as needed. Index on model_name or version if you need to quickly find a specific model. Fitness Scores – Tracks conformance of each journey to a model. A typical design is a junction table: e.g. Journey_Fitness(journey_id, model_id, fitness_score, calculated_at). Primary key can be composite (journey_id, model_id). This allows storing a fitness score for each journey-model pair (if multiple process models exist, e.g. different discovery results or model versions). If only one model is primary, an alternative is to keep a fitness_score column in the Journeys table, but a separate table is more flexible for multiple models or recalculations. Index this table on model_id (to query all journey scores for a given model) and on journey_id for quick lookup of a journey’s fitness. Aggregated Metrics – To avoid heavy computations on the fly, store precomputed process metrics in separate tables or materialized views. For example, a Variant_Stats table can hold variant_id, case_count (number of journeys of that variant), and maybe avg_duration. Another could be Model_Stats with metrics per model (e.g. overall fitness, number of conformant cases, etc.). These tables are updated periodically (or on new data ingestion) and provide snapshot insights. By separating them, analytical queries (dashboards, reports) hit a lightweight table rather than aggregating millions of events in real time.